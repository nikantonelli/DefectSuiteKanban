<!DOCTYPE html>
<html>
<head>
    <title>Kanban Board</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Allows configuring of rows for the cardboard
     *
     *
     *      @example
     *      Ext.create('Ext.Container', {
     *          items: [{
     *              xtype: 'rowsettingsfield',
     *              value: {
     *                  show: true,
     *                  field: 'c_ClassofService'
     *              }
     *          }],
     *          renderTo: Ext.getBody().dom
     *      });
     *
     */
    Ext.define('Rally.apps.common.RowSettingsField', {
        alias: 'widget.rowsettingsfield',
        extend: 'Ext.form.FieldContainer',
        requires: [
            'Rally.ui.CheckboxField',
            'Rally.ui.combobox.ComboBox',
            'Rally.ui.plugin.FieldValidationUi',
            'Rally.data.ModelFactory',
            'Rally.data.wsapi.ModelBuilder'
        ],

        mixins: {
            field: 'Ext.form.field.Field'
        },

        layout: 'hbox',

        cls: 'row-settings',

        config: {
            /**
             * @cfg {Object}
             *
             * The row settings value for this field
             */
            value: undefined,

            /**
             * @cfg {Function}
             * A function which should return true if the specified field should
             * be included in the list of available swimlane fields
             * @param {Rally.data.wsapi.Field} field
             */
            isAllowedFieldFn: Ext.emptyFn,

            /**
             * @cfg {Object[]}
             *
             * Array of objects with name and value keys to be used by the row combobox
             * [{'name': 'Blocked', 'value': 'Blocked'},{'name': 'Owner', 'value': 'Owner'}]
             */
            explicitFields: [],

            /**
             * @cfg {String[]}
             * Array of models for which to list fields for
             */
            modelNames: ['userstory', 'defect'],

            /**
             * @cfg {String[]}
             * Array of field display names to show if found on at least 1 model, sortable and are not hidden
             */
            whiteListFields: []
        },

        initComponent: function() {
            this.callParent(arguments);

            this.mixins.field.initField.call(this);

            this.add([
                {
                    xtype: 'rallycheckboxfield',
                    name: 'showRows',
                    boxLabel: '',
                    margin: '0',
                    submitValue: false,
                    value: this.getValue().showRows,
                    listeners: {
                        change: function(checkbox, checked) {
                            this.down('rallycombobox').setDisabled(!checked);
                        },
                        scope: this
                    }
                },
                {
                    xtype: 'rallycombobox',
                    plugins: ['rallyfieldvalidationui'],
                    name: 'rowsField',
                    margin: '0 6px',
                    width: 130,
                    emptyText: 'Choose Field...',
                    displayField: 'name',
                    valueField: 'value',
                    disabled: this.getValue().showRows !== 'true',
                    editable: false,
                    submitValue: false,
                    storeType: 'Ext.data.Store',
                    storeConfig: {
                        remoteFilter: false,
                        fields: ['name', 'value'],
                        data: []
                    }
                }
            ]);

            this._loadModels();
        },

        _loadModels: function() {
            Rally.data.ModelFactory.getModels({
                types: this.getModelNames(),
                context: this.context,
                success: this._onModelsRetrieved,
                scope: this
            });
        },

        _onModelsRetrieved: function (models) {
            var fields = _.uniq(Ext.Array.merge(this.explicitFields, this._getRowableFields(_.values(models))), 'name');
            var combobox = this.down('rallycombobox');
            combobox.getStore().loadData(_.sortBy(fields, 'name'));
            combobox.setValue(this.getValue().rowsField);
            this.fireEvent('ready', this);
        },

        _getRowableFields: function (models) {
            var artifactModel = Rally.data.wsapi.ModelBuilder.buildCompositeArtifact(models, this.context),
                allFields = artifactModel.getFields(),
                rowableFields = _.filter(allFields, function (field) {
                    var attr = field.attributeDefinition;
                    return attr && !attr.Hidden && attr.Sortable &&
                        ((artifactModel.getModelsForField(field).length === models.length &&
                        this.isAllowedFieldFn(field)) || _.contains(this.whiteListFields, field.displayName));
                }, this);

            return _.map(rowableFields, function(field) {
                return {
                    name: field.displayName,
                    value: field.name
                };
            });
        },

        /**
         * When a form asks for the data this field represents,
         * give it the name of this field and the ref of the selected project (or an empty string).
         * Used when persisting the value of this field.
         * @return {Object}
         */
        getSubmitData: function() {
            var data = {},
                showField = this.down('rallycheckboxfield'),
                rowsField = this.down('rallycombobox'),
                showRows = showField.getValue() && !_.isEmpty(rowsField.getValue());
            data[showField.name] = showRows;
            if (showRows) {
                data[rowsField.name] = rowsField.getValue();
            }
            return data;
        },

        refreshWithNewModelType: function(type) {
            this.setModelNames([type]);
            this._loadModels();
        }
    });
})();

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.kanban.Column', {
        extend: 'Rally.ui.cardboard.Column',
        alias: 'widget.kanbancolumn',

        config: {
            hideReleasedCards: false
        },

        getStoreFilter: function (model) {
            var filters = [];
            Ext.Array.push(filters, this.callParent(arguments));
            if (model.elementName === 'HierarchicalRequirement') {
                if (this.context.getSubscription().StoryHierarchyEnabled) {
                    filters.push({
                        property: 'DirectChildrenCount',
                        value: 0
                    });
                }
            }

            if (this.hideReleasedCards) {
                filters.push({
                    property: 'Release',
                    value: null
                });
            }

            return filters;
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * A picker which allows selecting one or more fields and a configurable right side action on bound list.
     */
    Ext.define('Rally.apps.kanban.ColumnCardFieldPicker', {
        extend: 'Rally.ui.picker.FieldPicker',
        alias: 'widget.kanbancolumncardfieldpicker',
        margin: 0,

        config: {
            /**
             * @cfg {String}
             * Initial text shown on right side of bound list
             */
            rightInitialText: 'Apply to All',

            /**
             * @cfg {String}
             * Text shown on right side of bound list after click
             */
            rightUpdateText: 'Remove from All',

            /**
             * @cfg {String}
             * Class for right side of bound list
             */
            rightCls: 'rui-picker-right-action hyperlink'

        },


        initComponent: function() {
            this.addEvents(
                /**
                 * @event rightactionclick
                 * Fires when a right side text was clicked in the picker
                 * @param {Rally.ui.picker.MultiObjectPicker} picker This picker
                 * @param {Object} value The newly clicked value
                 * @param {Object[]} values The currently selected values
                 * @param {Ext.Element} The element clicked
                 */
                'rightactionclick'
            );
            this.applyToAllFields = [];
            this.callParent(arguments);
        },

        onListItemDeselect: function(record, event) {
            var rightActionEl = this._getRightActionEl(record);

            if (rightActionEl && event.within(rightActionEl)) {
                var initialTextClicked = rightActionEl.getHTML() === this.rightInitialText;
                this.fireEvent('rightactionclick', this, record, this.getValue(), initialTextClicked);

                if (initialTextClicked) {
                    this.applyToAllFields.push(record.get(this.selectionKey));
                    this._selectRowCheckbox(record.get(this.recordKey));
                    rightActionEl.update(this.rightUpdateText);
                    return false;
                } else {
                    Ext.Array.remove(this.applyToAllFields, record.get(this.selectionKey));
                    rightActionEl.update(this.rightInitialText);
                }
            } else {
                Ext.Array.remove(this.applyToAllFields, record.get(this.selectionKey));
            }
            this.callParent(arguments);
        },

        getRightListHtml: function(recordData) {
            var tpl = '';
            if (recordData.groupSelected === 'Selected Fields' &&
                !Ext.Array.contains(this.alwaysSelectedValues, recordData[this.selectionKey])) {
                var text = Ext.Array.contains(this.applyToAllFields, recordData[this.selectionKey]) ? this.rightUpdateText: this.rightInitialText;
                tpl = '<div class="' + this.rightCls + '">' + text + '</div>';
            }
            return tpl;
        },

        _getRightActionEl: function(record) {
            var rightSelector = Ext.String.splitWords(this.rightCls).join('.');
            return this.list.getEl().down('.rui-multi-object-picker-option-id-' + record.get(this.recordKey) + ' .' + rightSelector);
        }

    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Allows configuration of wip and schedule state mapping for kanban columns
     *
     *      @example
     *      Ext.create('Ext.Container', {
     *          items: [{
     *              xtype: 'kanbancolumnsettingsfield',
     *              value: {}
     *          }],
     *          renderTo: Ext.getBody().dom
     *      });
     *
     */
    Ext.define('Rally.apps.kanban.ColumnSettingsField', {
        extend: 'Ext.form.field.Base',
        alias: 'widget.kanbancolumnsettingsfield',
        plugins: ['rallyfieldvalidationui'],
        requires: [
            'Rally.ui.combobox.ComboBox',
            'Rally.ui.TextField',
            'Rally.ui.combobox.FieldValueComboBox',
            'Rally.ui.plugin.FieldValidationUi',
            'Rally.apps.kanban.ColumnCardFieldPicker'
        ],

        fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',

        width: 600,
        cls: 'column-settings',

        config: {
            /**
             * @cfg {Object}
             *
             * The column settings value for this field
             */
            value: undefined,

            defaultCardFields: ''
        },

        onDestroy: function() {
            if (this._grid) {
                this._grid.destroy();
                delete this._grid;
            }
            this.callParent(arguments);
        },

        onRender: function() {
            this.callParent(arguments);

            this._store = Ext.create('Ext.data.Store', {
                fields: ['column', 'shown', 'wip', 'scheduleStateMapping', 'cardFields'],
                data: []
            });

            this._grid = Ext.create('Rally.ui.grid.Grid', {
                autoWidth: true,
                renderTo: this.inputEl,
                columnCfgs: this._getColumnCfgs(),
                showPagingToolbar: false,
                showRowActionsColumn: false,
                enableRanking: false,
                store: this._store,
                editingConfig: {
                    publishMessages: false
                }
            });
        },

        _getColumnCfgs: function() {
            var columns = [
                {
                    text: 'Column',
                    dataIndex: 'column',
                    emptyCellText: 'None',
                    flex: 2
                },
                {
                    text: 'Show',
                    dataIndex: 'shown',
                    flex: 1,
                    renderer: function (value) {
                        return value === true ? 'Yes' : 'No';
                    },
                    editor: {
                        xtype: 'rallycombobox',
                        displayField: 'name',
                        valueField: 'value',
                        editable: false,
                        storeType: 'Ext.data.Store',
                        storeConfig: {
                            remoteFilter: false,
                            fields: ['name', 'value'],
                            data: [
                                {'name': 'Yes', 'value': true},
                                {'name': 'No', 'value': false}
                            ]
                        }
                    }
                },
                {
                    text: 'WIP',
                    dataIndex: 'wip',
                    flex: 1,
                    emptyCellText: '&#8734;',
                    editor: {
                        xtype: 'rallytextfield',
                        maskRe: /[0-9]/,
                        validator: function (value) {
                            return (value === '' || (value > 0 && value <= 9999)) || 'WIP must be > 0 and < 9999.';
                        },
                        rawToValue: function (value) {
                            return value === '' ? value : parseInt(value, 10);
                        }
                    }
                },
                {
                    text: 'Schedule State Mapping',
                    dataIndex: 'scheduleStateMapping',
                    emptyCellText: '--No Mapping--',
                    flex: 2,
                    editor: {
                        xtype: 'rallyfieldvaluecombobox',
                        model: Ext.identityFn('HierarchicalRequirement'),
                        field: 'ScheduleState',
                        listeners: {
                            ready: function (combo) {
                                var noMapping = {};
                                noMapping[combo.displayField] = '--No Mapping--';
                                noMapping[combo.valueField] = '';

                                combo.store.insert(0, [noMapping]);
                            }
                        }
                    }
                }
            ];

            if (this.shouldShowColumnLevelFieldPicker) {
                columns.push({
                    text: 'Fields',
                    dataIndex: 'cardFields',
                    width: 300,
                    tdCls: Rally.util.Test.toBrowserTestCssClass('cardfields', ''),
                    renderer: this._getRendererForCardFields,
                    scope: this,
                    editor: {
                        xtype: 'kanbancolumncardfieldpicker',
                        cls: 'card-fields',
                        margin: 0,
                        modelTypes: ['UserStory', 'Defect'],
                        autoExpand: true,
                        alwaysExpanded: false,
                        hideTrigger: true,
                        fieldBlackList: ['DisplayColor'],
                        alwaysSelectedValues: ['FormattedID', 'Name', 'Owner'],
                        storeConfig: {
                            autoLoad: false
                        },
                        listeners: {
                            selectionchange: function (picker) {
                                picker.validate();
                            },
                            rightactionclick: this._updateColumnCardFieldSettings,
                            scope: this
                        }
                    }
                });
            }
            return columns;
        },

        /**
         * When a form asks for the data this field represents,
         * give it the name of this field and the ref of the selected project (or an empty string).
         * Used when persisting the value of this field.
         * @return {Object}
         */
        getSubmitData: function() {
            var data = {};
            data[this.name] = Ext.JSON.encode(this._buildSettingValue());
            return data;
        },

        _getRendererForCardFields: function(fields) {
            var valWithoutPrefixes = [];
            Ext.Array.each(this._getCardFields(fields), function(field) {
                valWithoutPrefixes.push(field.replace(/^c_/, ''));
            });
            return valWithoutPrefixes.join(', ');
        },

        _getCardFields: function(fields) {
            if (Ext.isString(fields) && fields) {
                return fields.split(',');
            }
            var val = ['FormattedID','Name','Owner'];
            Ext.Array.each(fields, function (currentItem) {
                if (currentItem && currentItem.data && !Ext.Array.contains(val, currentItem.data.name)) {
                    val.push(currentItem.data.name);
                }
            });
            return val;
        },

        _updateColumnCardFieldSettings: function(picker, selectedRecord, value, initialText) {
            this._store.each(function(record) {
                if (record.get('shown')) {
                    var cardFields = this._getCardFields(record.get('cardFields'));

                    if (initialText) {
                        if (!Ext.Array.contains(cardFields, selectedRecord.get('name'))) {
                            cardFields.push(selectedRecord.get('name'));
                        }
                    } else {
                        Ext.Array.remove(cardFields, selectedRecord.get('name'));
                    }
                    record.set('cardFields', cardFields.join(','));
                }
            }, this);

            this._store.loadRawData(this._store.getRange());
        },

        _buildSettingValue: function() {
            var columns = {};
            this._store.each(function(record) {
                if (record.get('shown')) {
                    columns[record.get('column')] = {
                        wip: record.get('wip'),
                        scheduleStateMapping: record.get('scheduleStateMapping')
                    };
                    if (this.shouldShowColumnLevelFieldPicker) {
                        var cardFields = this._getCardFields(record.get('cardFields'));
                        columns[record.get('column')].cardFields = cardFields.join(',');
                    }
                }
            }, this);
            return columns;
        },

        getErrors: function() {
            var errors = [];
            if (this._storeLoaded && !Ext.Object.getSize(this._buildSettingValue())) {
                errors.push('At least one column must be shown.');
            }
            return errors;
        },

        setValue: function(value) {
            this.callParent(arguments);
            this._value = value;
        },

        _getColumnValue: function(columnName) {
            var value = this._value;
            return value && Ext.JSON.decode(value)[columnName];
        },

        refreshWithNewField: function(field) {
            delete this._storeLoaded;
            field.getAllowedValueStore().load({
                callback: function(records) {
                    var data = Ext.Array.map(records, this._recordToGridRow, this);
                    this._store.loadRawData(data);
                    this.fireEvent('ready');
                    this._storeLoaded = true;
                },
                scope: this
            });
        },

        _recordToGridRow: function(allowedValue) {
            var columnName = allowedValue.get('StringValue');
            var pref = this._store.getCount() === 0 ? this._getColumnValue(columnName) : null;

            var column = {
                column: columnName,
                shown: false,
                wip: '',
                scheduleStateMapping: '',
                cardFields: this.defaultCardFields
            };

            if (pref) {
                Ext.apply(column, {
                    shown: true,
                    wip: pref.wip,
                    scheduleStateMapping: pref.scheduleStateMapping
                });

                if (pref.cardFields) {
                    Ext.apply(column, {
                        cardFields: pref.cardFields
                    });
                }
            }

            return column;

        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.kanban.Settings', {
        singleton: true,
        requires: [
            'Rally.apps.kanban.ColumnSettingsField',
            'Rally.apps.common.RowSettingsField',
            'Rally.ui.combobox.FieldComboBox',
            'Rally.ui.CheckboxField',
            'Rally.ui.plugin.FieldValidationUi'
        ],

        getFields: function(config) {
            var items = [
                {
                    name: 'groupByField',
                    xtype: 'rallyfieldcombobox',
                    model: Ext.identityFn('DefectSuite'),
                    margin: '10px 0 0 0',
                    fieldLabel: 'Columns',
                    listeners: {
                        select: function(combo) {
                            this.fireEvent('fieldselected', combo.getRecord().get('fieldDefinition'));
                        },
                        ready: function(combo) {
                            combo.store.filterBy(function(record) {
                                var attr = record.get('fieldDefinition').attributeDefinition;
                                return attr && !attr.ReadOnly && attr.Constrained && attr.AttributeType !== 'OBJECT' && attr.AttributeType !== 'COLLECTION';
                            });
                            if (combo.getRecord()) {
                                this.fireEvent('fieldselected', combo.getRecord().get('fieldDefinition'));
                            }
                        }
                    },
                    bubbleEvents: ['fieldselected', 'fieldready']
                },
                {
                    name: 'columns',
                    readyEvent: 'ready',
                    fieldLabel: '',
                    margin: '5px 0 0 80px',
                    xtype: 'kanbancolumnsettingsfield',
                    shouldShowColumnLevelFieldPicker: config.shouldShowColumnLevelFieldPicker,
                    defaultCardFields: config.defaultCardFields,
                    handlesEvents: {
                        fieldselected: function(field) {
                            this.refreshWithNewField(field);
                        }
                    },
                    listeners: {
                        ready: function() {
                            this.fireEvent('columnsettingsready');
                        }
                    },
                    bubbleEvents: 'columnsettingsready'
                }
            ];

            items.push({
                name: 'groupHorizontallyByField',
                xtype: 'rowsettingsfield',
                fieldLabel: 'Swimlanes',
                margin: '10 0 0 0',
                mapsToMultiplePreferenceKeys: ['showRows', 'rowsField'],
                readyEvent: 'ready',
                isAllowedFieldFn: function(field) {
                    var attr = field.attributeDefinition;
                    return ! field.isMultiValueCustom() &&
                    (   attr.Custom && (attr.Constrained || attr.AttributeType.toLowerCase() !== 'string') ||
                        attr.Constrained || _.contains(['boolean'], attr.AttributeType.toLowerCase())) &&
                        !_.contains(['web_link', 'text', 'date'], attr.AttributeType.toLowerCase());
                },
                explicitFields: [
                    {name: 'Sizing', value: 'PlanEstimate'}
               ]
            });

            items.push(
                {
                    name: 'hideReleasedCards',
                    xtype: 'rallycheckboxfield',
                    fieldLabel: 'Options',
                    margin: '10 0 0 0',
                    boxLabel: 'Hide cards in last visible column if assigned to a release'
                },
                {
                    type: 'cardage',
                    config: {
                        fieldLabel: '',
                        margin: '5 0 10 80'
                    }
                },
                {
                    type: 'query'
                });

            return items;
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.kanban.KanbanApp', {
        extend: 'Rally.app.App',
        requires: [
            'Rally.apps.kanban.Settings',
            'Rally.apps.kanban.Column',
            'Rally.ui.gridboard.GridBoard',
            'Rally.ui.gridboard.plugin.GridBoardAddNew',
            'Rally.ui.gridboard.plugin.BoardPolicyDisplayable',
            'Rally.ui.cardboard.plugin.ColumnPolicy',
            'Rally.ui.cardboard.PolicyContainer',
            'Rally.ui.cardboard.CardBoard',
            'Rally.ui.cardboard.plugin.Scrollable',
            'Rally.ui.report.StandardReport',
            'Rally.clientmetrics.ClientMetricsRecordable',
            'Rally.ui.gridboard.plugin.GridBoardCustomFilterControl',
            'Rally.ui.gridboard.plugin.GridBoardFieldPicker',
            'Rally.ui.cardboard.plugin.FixedHeader'
        ],
        mixins: [
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],
        cls: 'kanban',
        alias: 'widget.kanbanapp',
        appName: 'Kanban',
        helpId: 238,

        settingsScope: 'project',
        autoScroll: false,
        layout: 'fit',

        config: {
            defaultSettings: {
                groupByField: 'ScheduleState',
                showRows: false,
                columns: Ext.JSON.encode({
                    Defined: {wip: ''},
                    'In-Progress': {wip: ''},
                    Completed: {wip: ''},
                    Accepted: {wip: ''}
                }),
                cardFields: 'FormattedID,Name,Owner,Discussion,Tasks,Defects', //remove with COLUMN_LEVEL_FIELD_PICKER_ON_KANBAN_SETTINGS
                hideReleasedCards: false,
                showCardAge: true,
                cardAgeThreshold: 3,
                pageSize: 25
            }
        },

        launch: function() {
            Rally.data.ModelFactory.getModel({
                type: 'DefectSuite',
                success: this._onStoryModelRetrieved,
                scope: this
            });
        },

        getOptions: function() {
            return [
                {
                    text: 'Show Cycle Time Report',
                    handler: this._showCycleTimeReport,
                    scope: this
                },
                {
                    text: 'Show Throughput Report',
                    handler: this._showThroughputReport,
                    scope: this
                },
                {
                    text: 'Print',
                    handler: this._print,
                    scope: this
                }
            ];
        },

        getSettingsFields: function() {
            return Rally.apps.kanban.Settings.getFields({
                shouldShowColumnLevelFieldPicker: this._shouldShowColumnLevelFieldPicker(),
                defaultCardFields: this.getSetting('cardFields')
            });
        },

        /**
         * Called when any timebox scope change is received.
         * @protected
         * @param {Rally.app.TimeboxScope} timeboxScope The new scope
         */
        onTimeboxScopeChange: function() {
            this.callParent(arguments);
            this.gridboard.destroy();
            this.launch();
        },

        _shouldShowColumnLevelFieldPicker: function() {
            return this.getContext().isFeatureEnabled('COLUMN_LEVEL_FIELD_PICKER_ON_KANBAN_SETTINGS');
        },

        _onStoryModelRetrieved: function(model) {
            this.groupByField = model.getField(this.getSetting('groupByField'));
            this._addCardboardContent();
        },

        _addCardboardContent: function() {
            var cardboardConfig = this._getCardboardConfig();

            var columnSetting = this._getColumnSetting();
            if (columnSetting) {
                cardboardConfig.columns = this._getColumnConfig(columnSetting);
            }

            this.gridboard = this.add(this._getGridboardConfig(cardboardConfig));
        },

        _getGridboardConfig: function(cardboardConfig) {
            var context = this.getContext(),
                modelNames = this._getDefaultTypes(),
                blackListFields = ['Successors', 'Predecessors', 'DisplayColor'],
                whiteListFields = ['Milestones', 'Tags'];
           
            return {
                xtype: 'rallygridboard',
                stateful: false,
                toggleState: 'board',
                cardBoardConfig: cardboardConfig,
                plugins: [
                    {
                        ptype: 'rallygridboardaddnew',
                        addNewControlConfig: {
                            listeners: {
                                beforecreate: this._onBeforeCreate,
                                beforeeditorshow: this._onBeforeEditorShow,
                                scope: this
                            },
                            stateful: true,
                            stateId: context.getScopedStateId('kanban-add-new')
                        }
                    },
                    {
                        ptype: 'rallygridboardinlinefiltercontrol',
                        inlineFilterButtonConfig: {
                            stateful: true,
                            stateId: context.getScopedStateId('kanban-inline-filter'),
                            modelNames: modelNames,
                            legacyStateIds: [
                                context.getScopedStateId('kanban-owner-filter'),
                                context.getScopedStateId('kanban-custom-filter-button')
                            ],
                            filterChildren: true,
                            inlineFilterPanelConfig: {
                                quickFilterPanelConfig: {
                                    defaultFields: ['ArtifactSearch', 'Owner'],
                                    addQuickFilterConfig: {
                                        blackListFields: blackListFields,
                                        whiteListFields: whiteListFields
                                    }
                                },
                                advancedFilterPanelConfig: {
                                    advancedFilterRowsConfig: {
                                        propertyFieldConfig: {
                                            blackListFields: blackListFields,
                                            whiteListFields: whiteListFields
                                        }
                                    }
                                }
                            }
                        }
                    },
                    {
                        ptype: 'rallygridboardfieldpicker',
                        headerPosition: 'left',
                        boardFieldBlackList: blackListFields,
                        modelNames: modelNames
                    },
                    {
                        ptype: 'rallyboardpolicydisplayable',
                        prefKey: 'kanbanAgreementsChecked',
                        checkboxConfig: {
                            boxLabel: 'Show Agreements'
                        }
                    }
                ],
                context: context,
                modelNames: modelNames,
                storeConfig: {
                    filters: this._getFilters()
                },
                height: this.getHeight()
            };
        },

        _getColumnConfig: function(columnSetting) {
            var columns = [];
            Ext.Object.each(columnSetting, function(column, values) {
                var columnConfig = {
                    xtype: 'kanbancolumn',
                    enableWipLimit: true,
                    wipLimit: values.wip,
                    plugins: [{
                        ptype: 'rallycolumnpolicy',
                        app: this
                    }],
                    value: column,
                    columnHeaderConfig: {
                        headerTpl: column || 'None'
                    },
                    listeners: {
                        invalidfilter: {
                            fn: this._onInvalidFilter,
                            scope: this
                        }
                    }
                };
                if(this._shouldShowColumnLevelFieldPicker()) {
                    columnConfig.fields = this._getFieldsForColumn(values);
                }
                columns.push(columnConfig);
            }, this);

            columns[columns.length - 1].hideReleasedCards = this.getSetting('hideReleasedCards');

            return columns;
        },

        _getFieldsForColumn: function(values) {
            var columnFields = [];
            if (this._shouldShowColumnLevelFieldPicker()) {
                if (values.cardFields) {
                    columnFields = values.cardFields.split(',');
                } else if (this.getSetting('cardFields')) {
                    columnFields = this.getSetting('cardFields').split(',');
                }
            }
            return columnFields;
        },

        _onInvalidFilter: function() {
            Rally.ui.notify.Notifier.showError({
                message: 'Invalid query: ' + this.getSetting('query')
            });
        },

        _getCardboardConfig: function() {
            var config = {
                xtype: 'rallycardboard',
                plugins: [
                    {
                        ptype: 'rallycardboardprinting',
                        pluginId: 'print'
                    },
                    {
                        ptype: 'rallyscrollablecardboard',
                        containerEl: this.getEl()
                    },
                    {ptype: 'rallyfixedheadercardboard'}
                ],
                types: this._getDefaultTypes(),
                attribute: this.getSetting('groupByField'),
                margin: '10px',
                context: this.getContext(),
                listeners: {
                    beforecarddroppedsave: this._onBeforeCardSaved,
                    load: this._onBoardLoad,
                    cardupdated: this._publishContentUpdatedNoDashboardLayout,
                    scope: this
                },
                columnConfig: {
                    xtype: 'rallycardboardcolumn',
                    enableWipLimit: true,
                    fields: this.getSetting('cardFields').split(',')
                },
                cardConfig: {
                    editable: true,
                    showIconMenus: true,
                    showAge: this.getSetting('showCardAge') ? this.getSetting('cardAgeThreshold') : -1,
                    showBlockedReason: true
                },
                storeConfig: {
                    context: this.getContext().getDataContext()
                }
            };
            if (this.getSetting('showRows')) {
                Ext.merge(config, {
                    rowConfig: {
                        field: this.getSetting('rowsField'),
                        sortDirection: 'ASC'
                    }
                });
            }
            return config;
        },

        _getFilters: function() {
            var filters = [];
            if(this.getSetting('query')) {
                filters.push(Rally.data.QueryFilter.fromQueryString(this.getSetting('query')));
            }
            if(this.getContext().getTimeboxScope()) {
                filters.push(this.getContext().getTimeboxScope().getQueryFilter());
            }
            return filters;
        },

        _getColumnSetting: function() {
            var columnSetting = this.getSetting('columns');
            return columnSetting && Ext.JSON.decode(columnSetting);
        },

        _buildReportConfig: function(report) {
            var reportConfig = {
                report: report,
                work_items: this._getWorkItemTypesForChart()
            };
            if (this.getSetting('groupByField') !== 'ScheduleState') {
                reportConfig.filter_field = this.groupByField.displayName;
            }
            return reportConfig;
        },

        _showCycleTimeReport: function() {
            this._showReportDialog('Cycle Time Report',
                this._buildReportConfig(Rally.ui.report.StandardReport.Reports.CycleLeadTime));
        },

        _showThroughputReport: function() {
            this._showReportDialog('Throughput Report',
                this._buildReportConfig(Rally.ui.report.StandardReport.Reports.Throughput));
        },

        _print: function() {
            this.gridboard.getGridOrBoard().openPrintPage({title: 'Kanban Board'});
        },

        _getWorkItemTypesForChart: function() {
            var types = this.gridboard.getGridOrBoard().getTypes(),
                typeMap = {
                    hierarchicalrequirement: 'G',
                    defect: 'D'
                };
            return types.length === 2 ? 'N' : typeMap[types[0]];
        },

        _getDefaultTypes: function() {
            return ['DefectSuite'];
        },

        _buildStandardReportConfig: function(reportConfig) {
            var scope = this.getContext().getDataContext();
            return {
                xtype: 'rallystandardreport',
                padding: 10,
                project: scope.project,
                projectScopeUp: scope.projectScopeUp,
                projectScopeDown: scope.projectScopeDown,
                reportConfig: reportConfig
            };
        },

        _showReportDialog: function(title, reportConfig) {
            var height = 450, width = 600;
            this.getEl().mask();
            Ext.create('Rally.ui.dialog.Dialog', {
                title: title,
                autoShow: true,
                draggable: false,
                closable: true,
                modal: false,
                height: height,
                width: width,
                items: [
                    Ext.apply(this._buildStandardReportConfig(reportConfig),
                        {
                            height: height,
                            width: width
                        })
                ],
                listeners: {
                    close: function() {
                        this.getEl().unmask();
                    },
                    scope: this
                }
            });
        },

        _onBoardLoad: function() {
            this._publishContentUpdated();
            this.setLoading(false);
        },

        _onBeforeCreate: function(addNew, record, params) {
            Ext.apply(params, {
                rankTo: 'BOTTOM',
                rankScope: 'BACKLOG'
            });
            record.set(this.getSetting('groupByField'), this.gridboard.getGridOrBoard().getColumns()[0].getValue());
        },

        _onBeforeEditorShow: function(addNew, params) {
            params.rankTo = 'BOTTOM';
            params.rankScope = 'BACKLOG';
            params.iteration = 'u';

            var groupByFieldName = this.groupByField.name;

            params[groupByFieldName] = this.gridboard.getGridOrBoard().getColumns()[0].getValue();
        },

        _onBeforeCardSaved: function(column, card) {
            var columnSetting = this._getColumnSetting();
            if (columnSetting) {
                var setting = columnSetting[column.getValue()];
                if (setting && setting.scheduleStateMapping) {
                    card.getRecord().set('ScheduleState', setting.scheduleStateMapping);
                }
            }
        },

        _publishContentUpdated: function() {
            this.fireEvent('contentupdated');
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
            this.recordComponentReady({
                miscData: {
                    swimLanes: this.getSetting('showRows'),
                    swimLaneField: this.getSetting('rowsField')
                }
            });
        },

        _publishContentUpdatedNoDashboardLayout: function() {
            this.fireEvent('contentupdated', {dashboardLayout: false});
        }
    });
})();


            Rally.launchApp('Rally.apps.kanban.KanbanApp', {
                name:"Kanban Board",
                parentRepos:"",
                version:"0.1.1"
            });

        });
    </script>



    <style type="text/css">
        .ext-ie .kanban .rly-right .filterInfo {
  width: 25px;
}
.ext-ie .kanban .rly-right .artifact-type-chooser {
  width: 265px;
}
.cardboard .status-content > .status-field.RevisionHistory {
  line-height: 18px;
  cursor: default;
}
.column-settings .settings-grid {
  border: 1px solid #FFF;
}
.column-settings .settings-grid.rally-invalid-field {
  border: 1px solid #F00;
}
.row-settings .x-form-item-input-row .x-field-label-cell {
  vertical-align: top;
}
.rui-picker-right-action {
  display: inline;
  float: right;
  padding-right: 4px;
}
.kanban {
  overflow-y: hidden;
}
.print-page .cardboard {
  height: auto !important;
}
.print-page .cardboard .fixed-header-card-board-body-container > table {
  position: absolute;
  width: calc(100% - 24px);
}

    </style>
</head>
<body>
</body>
</html>
